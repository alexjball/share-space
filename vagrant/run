#!/bin/bash
#
# Groups commands for controlling the vagrant environment

source $(dirname $(realpath $0))/base_env $(dirname $(dirname $(realpath $0)))

### Configuration

NODE_VERSION=v12.13.0

XDISPLAY=0
# Using .Xauthority is potentially less secure than host access with only local access.
# Since the file needs to be readable by the in-session user, it can potentially be 
# read over the stream, and gaining a connection to the VM allows taking over the 
# session. Restricting to local access means you need shell access, which is generally
# more locked down than the private network of the VM.
XAUTHORITY=~/.Xauthority 
SCREEN_WIDTH=1280
SCREEN_HEIGHT=720
FRAMERATE=30

RUN=$PROJECT_ROOT/vagrant/run

FRONTEND_SOURCE=~/dev/share-space

FFMPEG_SOURCE=$PROJECT_ROOT/ffmpeg
FFMPEG_BUILD=$PROJECT_ROOT/build/ffmpeg
FFMPEG_INSTALL=$FFMPEG_BUILD/install

MEDIA_SINK_SOCKET=$PROJECT_ROOT/build/server/share-space-media-sink.sock
INFO_SINK_SOCKET=$PROJECT_ROOT/build/server/share-space-info-sink.sock

### Implementations

install_node() {
  if [ -z $(command -v nvm) ]; then
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.0/install.sh | bash || echo "Error installing nvm"; exit 1
    source ~/.bashrc
    [ -n $(command -v nvm) ] || echo "Can't find nvm after installing"; exit 1
  fi

  if [ -z $(which node) -o $(node -v) != $NODE_VERSION ]; then
    nvm install $NODE_VERSION || echo "Error installing node $NODE_VERSION"; exit 1
    [ $(node -v) == $NODE_VERSION ] || echo "Wrong node version after installing"; exit 1
  fi
}

_kill() {
  local PIDS=($(pgrep $1))

  for pid in ${PIDS[*]}; do
    [ -d "/proc/$pid" ] && echo "Killing $1 with PID $pid"
    kill $pid 2&>1 /dev/null
    timeout 3s tail --pid=$pid -f /dev/null
    kill -KILL $pid 2&>1 /dev/null
  done
}

stack_status() {
  ps -e | grep -i -E '(x|node|ffmpeg)'
}

stack_up() {
  vagrant/run run_Xvfb &
  vagrant/run run_x11vnc &
  vagrant/run \
    screen_capture_stream_test \
    unix://$FRONTEND_SOURCE/build/server/share-space-info-sink.sock \
    unix://$FRONTEND_SOURCE/build/server/share-space-media-sink.sock &
  vagrant/run run_frontend &
}

stack_down() {
  _kill x11vnc
  _kill Xvfb
  _kill ffmpeg
  _kill node
}

run_frontend() {
  cd $FRONTEND_SOURCE && \
  npm start
}

run_Xvfb() {
  xvfb-run \
    --server-num=$XDISPLAY \
    --auth-file=$XAUTHORITY \
    --server-args="-screen 0 ${SCREEN_WIDTH}x${SCREEN_HEIGHT}x24" \
    /etc/X11/Xsession cinnamon-session
}

run_x11vnc() {
  x11vnc \
    -auth $XAUTHORITY \
    -display :$XDISPLAY \
    -nevershared \
    -loop \
    -forever 
}

update() {
  sudo apt-get -y update
}

install_frontend() {
  cd $FRONTEND_SOURCE && \
  git clone https://github.com/alexjball/share-space.git && \
  cd share-space && \
  npm install && \
  cd client && \
  npm install
}

install_gui_deps() {
  # TODO: Figure out which desktop environment and GUI apps to install
  # TODO: Figure out how to configure the desktop environment for an X server
  # TODO: Add a command to start and stop an X session
  # TODO: Eventually add a command to start and stop an X session, ffmpeg stream, and room server together.
  # Try xvfb-run --server-args="-screen 0 1024x768x24" ico -faces
  # Xvfb is the X server plus a framebuffer. A display manager provides a GUI around sessions and windows
  # managers. We don't need that since we're starting sessions on server startup. A session manager 
  # initializes programs in a graphical login session, so this is where we configure the web browser to open.
  # A window manager provides the in-session GUI around program windows; we should use a simple floating
  # window manager.
  # X clients (which is effectively what x11grab is) use the display number to resolve the local socket to
  # use to connect to the X server. They also send an auth key, which is stored in an Xauthority file, the
  # path to which is set to $XAUTHORITY before initializing a session. Since no one else is accessing the
  # server, it may be OK to disable auth. If not, x11grab will need access to the key, so might need to 
  # set XAUTHORITY in a shell above x11grab and the X server.
  sudo apt-get -y install \
    xvfb \
    x11vnc
    # cinnamon-core \
    # xinit \
    # dbus-x11 \
    # firefox (doesn't seem to support all video providers with DRM enabled)
    # https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
    # pavucontrol
    # TODO: Better cursor, may be x11vnc

  # Prevent lightdm from running
  sudo systemctl disable display-manager.service
}

install_ffmpeg_deps() {
  sudo apt-get -y install \
    autoconf \
    automake \
    build-essential \
    cmake \
    git-core \
    libass-dev \
    libfreetype6-dev \
    libsdl2-dev \
    libtool \
    libva-dev \
    libvdpau-dev \
    libvorbis-dev \
    libxcb1-dev \
    libxcb-shm0-dev \
    libxcb-xfixes0-dev \
    pkg-config \
    texinfo \
    zlib1g-dev \
    libx264-dev \
    libvpx-dev \
    libopus-dev
}

configure_ffmpeg() {
	cd $FFMPEG_BUILD
	$FFMPEG_SOURCE/configure \
		--prefix=$FFMPEG_INSTALL \
		--enable-libvpx \
		--enable-libopus \
    --enable-libvorbis \
		--enable-libx264 \
    --enable-libpulse \
		--enable-gpl \
		--enable-shared
}

build_ffmpeg() {
	configure_ffmpeg && \
		make -j $(nproc) && \
		make install
}

screen_capture_stream_test() {
  local INFO_URL=${1:-"unix://$INFO_SINK_SOCKET"}
	local MEDIA_URL=${2:-"unix://$MEDIA_SINK_SOCKET"}

  ffmpeg \
    -v info \
    -f pulse \
      -channels 2 \
      -thread_queue_size 500 \
      -i default \
    -f x11grab \
      -probesize 32 \
      -video_size ${SCREEN_WIDTH}x${SCREEN_HEIGHT} \
      -framerate $FRAMERATE \
      -i :0 \
    -threads 0 \
    -pix_fmt yuv420p \
    -c:a libvorbis \
    -c:v libvpx-vp9 \
      -quality realtime \
      -speed 8 \
      -qmin 4 -qmax 48 \
      -crf 15 \
      -b:v 1000k \
      -static-thresh 0 \
      -max-intra-rate 300 \
      -lag-in-frames 0 \
      -error-resilient 1 \
      -tile-columns 4 \
      -frame-parallel 1 \
      -row-mt 1 \
    -f webm_streaming_chunk \
      -info_url $INFO_URL \
      $MEDIA_URL
}

stream_test() {
	INFO_URL=${1:-"unix://$INFO_SINK_SOCKET"}
	MEDIA_URL=${2:-"unix://$MEDIA_SINK_SOCKET"}

	# Stream an infinite video loop to the room server
	# bin and lib paths are configured in bashrc
  ffmpeg \
		-re \
		-i $PROJECT_ROOT/assets/earth.mp4 \
		-vf "loop=loop=-1:size=30:start=0,realtime" \
		-f webm_streaming_chunk \
		-info_url $INFO_URL \
		$MEDIA_URL
}

help() {
  echo "Usage: $prog_name { $(join_by " | " ${CMDS[*]}) } [args ...]"
}

### Command Line Interface

join_by() {
  local d=$1; 
  shift; 
  echo -n "$1"; 
  shift; 
  printf "%s" "${@/#/$d}"
}

CMDS=(install_node \
      run_Xvfb \
      run_x11vnc \
      update \
      install_gui_deps \
      install_ffmpeg_deps \
      configure_ffmpeg \
      build_ffmpeg \
      stream_test \
      screen_capture_stream_test \
      stack_up \
      stack_down \
      stack_status \
      install_frontend \
      run_frontend \
      help)

prog_name=$0
cmd=$1
shift || true

for option in ${CMDS[*]}; do
  if [ "$cmd" == "$option" ]; then
    $cmd $@
    exit
  fi
done

echo "Unrecognized command $cmd"
help
exit 1
